#!/usr/bin/env python3
"""
watsonx Orchestrate Skill Compiler
Converts declarative SKILL.yaml ‚Üí watsonx MCP server (server.py + openapi.yaml + docs)

Usage:
    wxo compile vault-auditor.skill.yaml
    wxo compile vault-auditor.skill.yaml --output-dir ./generated

‚ö†Ô∏è EXPERIMENTAL CODE - NO WARRANTY
"""

import sys
import os
import yaml
import json
import argparse
from pathlib import Path
from typing import Dict, Any, List
from datetime import datetime

VERSION = "1.0.0"

# Templates
SERVER_TEMPLATE = '''#!/usr/bin/env python3
"""
{name}
{description}

Auto-generated by wxo-skill-compiler v{compiler_version}
DO NOT EDIT MANUALLY - Edit {skill_file} and recompile

‚ö†Ô∏è EXPERIMENTAL CODE - NO WARRANTY
"""

import os
import logging
from typing import List, Dict, Any
from dotenv import load_dotenv
from mcp.server.fastmcp import FastMCP
{extra_imports}

load_dotenv()
logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")

# Initialize MCP server
mcp = FastMCP("{name}")

# Environment configuration
{env_config}

{helper_functions}

{tools}

{resources}

if __name__ == "__main__":
    logging.info("Starting {name} MCP Server...")
    mcp.run()
'''

OPENAPI_TEMPLATE = '''openapi: 3.0.0
info:
  title: {title}
  version: {version}
  description: |
    {description}
    
    ‚ö†Ô∏è EXPERIMENTAL CODE - NO WARRANTY
    Auto-generated by wxo-skill-compiler

servers:
  - url: http://localhost:8000
    description: Local development
  - url: https://{{{{server}}}}/api
    description: Production deployment

{paths}

{components}
'''

AGENT_TEMPLATE = '''name: {name}-agent
version: {version}
description: "{description}"

instructions: |
{grounding}

model: {model}
temperature: {temperature}
max_tokens: {max_tokens}

tools:
{tools}

{resources}
'''

README_TEMPLATE = '''# {name}

{tagline}

‚ö†Ô∏è **EXPERIMENTAL CODE** - Auto-generated by wxo-skill-compiler. Use at your own risk.

## Overview

{description}

## Features

{features}

## Quick Start

```bash
# Install dependencies
pip install -r requirements.txt

# Configure environment
cp .env.example .env
# Edit .env with your credentials

# Run MCP server
python server.py
```

## Import to watsonx Orchestrate

```bash
orchestrate toolkits import \\
  --kind mcp \\
  --name {name} \\
  --package-root . \\
  --command "python server.py"

orchestrate agents import -f agents/agent.yaml
```

## Use Cases

{use_cases}

## Example Usage

{examples}

## Dependencies

{dependencies}

## License

{license}

---

*Generated by [wxo-skill-compiler](https://github.com/YOUR-ORG/wxo-skill-compiler) v{compiler_version}*
'''


class SkillCompiler:
    """Compiles declarative SKILL.yaml to watsonx Orchestrate MCP server"""
    
    def __init__(self, skill_file: Path, output_dir: Path = None):
        self.skill_file = skill_file
        self.output_dir = output_dir or Path(skill_file.stem)
        self.skill = self._load_skill()
        
    def _load_skill(self) -> Dict[str, Any]:
        """Load and validate skill YAML"""
        with open(self.skill_file) as f:
            skill = yaml.safe_load(f)
        
        # Validate required fields
        required = ['name', 'description', 'tools']
        missing = [f for f in required if f not in skill]
        if missing:
            raise ValueError(f"Missing required fields: {missing}")
        
        return skill
    
    def compile(self):
        """Main compilation orchestrator"""
        print(f"üî® Compiling skill: {self.skill['name']}")
        
        # Create output directory
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Generate all components
        self._generate_server()
        self._generate_openapi()
        self._generate_requirements()
        self._generate_env_example()
        self._generate_agent()
        self._generate_readme()
        
        print(f"‚úÖ Skill compiled to: {self.output_dir}/")
        print(f"\nNext steps:")
        print(f"  cd {self.output_dir}")
        print(f"  pip install -r requirements.txt")
        print(f"  cp .env.example .env  # Configure credentials")
        print(f"  python server.py      # Test locally")
        print(f"  orchestrate toolkits import --kind mcp --package-root .")
    
    def _generate_server(self):
        """Generate server.py"""
        
        # Collect extra imports
        extra_imports = []
        if self.skill.get('mcp_dependencies'):
            # MCP dependencies are accessed via their own servers
            pass
        
        # Environment configuration
        env_config = []
        for dep in self.skill.get('mcp_dependencies', []):
            for var in dep.get('env_vars', []):
                env_config.append(f'{var} = os.getenv("{var}")')
        
        # Helper functions
        helpers = []
        for tool in self.skill.get('tools', []):
            for helper in tool.get('helpers', []):
                helpers.append(f"\n{helper['code']}\n")
        
        # Tools
        tools = []
        for tool in self.skill['tools']:
            tool_code = self._generate_tool_function(tool)
            tools.append(tool_code)
        
        # Resources
        resources = []
        for resource in self.skill.get('resources', []):
            resource_code = self._generate_resource_function(resource)
            resources.append(resource_code)
        
        # Render template
        server_code = SERVER_TEMPLATE.format(
            name=self.skill['name'],
            description=self.skill['description'],
            compiler_version=VERSION,
            skill_file=self.skill_file.name,
            extra_imports='\n'.join(extra_imports),
            env_config='\n'.join(env_config),
            helper_functions='\n'.join(helpers),
            tools='\n\n'.join(tools),
            resources='\n\n'.join(resources)
        )
        
        (self.output_dir / 'server.py').write_text(server_code)
        print(f"  ‚úì server.py")
    
    def _generate_tool_function(self, tool: Dict) -> str:
        """Generate MCP tool function from spec"""
        
        # Build function signature
        params = []
        for inp in tool.get('inputs', []):
            param_type = self._python_type(inp['type'])
            default = f" = {repr(inp['default'])}" if 'default' in inp else ""
            params.append(f"{inp['name']}: {param_type}{default}")
        
        signature = f"def {tool['name']}({', '.join(params)}) -> str:"
        
        # Build docstring
        docstring = f'    """\n    {tool["description"]}\n'
        docstring += '\n    Args:\n'
        for inp in tool.get('inputs', []):
            docstring += f'        {inp["name"]}: {inp["description"]}\n'
        docstring += '\n    Returns:\n'
        docstring += '        JSON string with results\n'
        docstring += '    """\n'
        
        # Build implementation
        impl = tool.get('implementation', '    # TODO: Implement logic\n    return "{}"')
        impl = '\n'.join(f'    {line}' for line in impl.split('\n'))
        
        # Combine
        return f"@mcp.tool()\n{signature}\n{docstring}{impl}\n"
    
    def _generate_resource_function(self, resource: Dict) -> str:
        """Generate MCP resource function from spec"""
        
        content_json = json.dumps(resource.get('content', {}), indent=2)
        
        return f'''@mcp.resource("{resource['uri']}")
def {resource['name'].replace('-', '_')}() -> str:
    """
    {resource.get('description', f'{resource["name"]} resource')}
    """
    return {repr(content_json)}
'''
    
    def _python_type(self, schema_type: str) -> str:
        """Convert JSON schema type to Python type hint"""
        mapping = {
            'string': 'str',
            'integer': 'int',
            'number': 'float',
            'boolean': 'bool',
            'array': 'List',
            'object': 'Dict'
        }
        return mapping.get(schema_type, 'Any')
    
    def _generate_openapi(self):
        """Generate openapi.yaml"""
        
        # Generate paths
        paths = {}
        for tool in self.skill['tools']:
            path = f"/{tool['name'].replace('_', '-')}"
            paths[path] = {
                'post': {
                    'operationId': tool['name'],
                    'summary': tool['description'],
                    'requestBody': self._openapi_request_body(tool),
                    'responses': self._openapi_responses(tool)
                }
            }
        
        paths_yaml = yaml.dump({'paths': paths}, default_flow_style=False)
        
        # Generate components (schemas)
        components_yaml = "components:\n  schemas: {}"
        
        spec = OPENAPI_TEMPLATE.format(
            title=self.skill['name'],
            version=self.skill.get('version', '1.0.0'),
            description=self.skill['description'],
            paths=paths_yaml,
            components=components_yaml
        )
        
        (self.output_dir / 'openapi.yaml').write_text(spec)
        print(f"  ‚úì openapi.yaml")
    
    def _openapi_request_body(self, tool: Dict) -> Dict:
        """Generate OpenAPI request body from tool inputs"""
        properties = {}
        required = []
        
        for inp in tool.get('inputs', []):
            properties[inp['name']] = {
                'type': inp['type'],
                'description': inp['description']
            }
            if inp.get('required', False):
                required.append(inp['name'])
        
        return {
            'required': True,
            'content': {
                'application/json': {
                    'schema': {
                        'type': 'object',
                        'required': required,
                        'properties': properties
                    }
                }
            }
        }
    
    def _openapi_responses(self, tool: Dict) -> Dict:
        """Generate OpenAPI responses from tool outputs"""
        return {
            '200': {
                'description': 'Success',
                'content': {
                    'application/json': {
                        'schema': tool.get('outputs', {'type': 'object'})
                    }
                }
            }
        }
    
    def _generate_requirements(self):
        """Generate requirements.txt"""
        deps = [
            'fastmcp>=0.1.0',
            'mcp>=1.0.0',
            'python-dotenv>=1.0.0'
        ]
        
        # Add skill-specific dependencies
        deps.extend(self.skill.get('python_dependencies', []))
        
        (self.output_dir / 'requirements.txt').write_text('\n'.join(deps) + '\n')
        print(f"  ‚úì requirements.txt")
    
    def _generate_env_example(self):
        """Generate .env.example"""
        env_vars = []
        
        for dep in self.skill.get('mcp_dependencies', []):
            env_vars.append(f"# {dep['name']} MCP server")
            for var in dep.get('env_vars', []):
                env_vars.append(f"{var}=YOUR_{var}_HERE")
            env_vars.append("")
        
        (self.output_dir / '.env.example').write_text('\n'.join(env_vars))
        print(f"  ‚úì .env.example")
    
    def _generate_agent(self):
        """Generate agents/agent.yaml"""
        
        agent_dir = self.output_dir / 'agents'
        agent_dir.mkdir(exist_ok=True)
        
        agent_config = self.skill.get('agent', {})
        
        # Format tools list
        tools_list = '\n'.join(
            f"  - {self.skill['name']}.{tool['name']}"
            for tool in self.skill['tools']
        )
        
        # Format resources list
        resources_list = ""
        if self.skill.get('resources'):
            resources_list = "resources:\n" + '\n'.join(
                f"  - {resource['uri']}"
                for resource in self.skill['resources']
            )
        
        # Indent grounding
        grounding = '\n'.join(
            f"  {line}" for line in self.skill.get('grounding', '').split('\n')
        )
        
        agent_yaml = AGENT_TEMPLATE.format(
            name=self.skill['name'],
            version=self.skill.get('version', '1.0.0'),
            description=self.skill['description'],
            grounding=grounding,
            model=agent_config.get('model', 'ibm/granite-3.1-8b-instruct'),
            temperature=agent_config.get('temperature', 0.3),
            max_tokens=agent_config.get('max_tokens', 2000),
            tools=tools_list,
            resources=resources_list
        )
        
        (agent_dir / 'agent.yaml').write_text(agent_yaml)
        print(f"  ‚úì agents/agent.yaml")
    
    def _generate_readme(self):
        """Generate README.md"""
        
        readme_config = self.skill.get('readme', {})
        
        # Features list
        features_md = '\n'.join(
            f"- {feature}" for feature in readme_config.get('features', [])
        )
        
        # Use cases
        use_cases_md = '\n'.join(
            f"- {uc}" for uc in readme_config.get('use_cases', [])
        )
        
        # Examples
        examples_md = ""
        for example in self.skill.get('examples', []):
            examples_md += f"### {example['name']}\n\n"
            examples_md += f"**Input:**\n```json\n{json.dumps(example['input'], indent=2)}\n```\n\n"
            if 'output' in example:
                examples_md += f"**Output:**\n```json\n{json.dumps(example['output'], indent=2)}\n```\n\n"
        
        # Dependencies
        deps_md = ""
        for dep in self.skill.get('mcp_dependencies', []):
            deps_md += f"- **{dep['name']}**: {dep.get('package', 'N/A')} (v{dep.get('version', 'latest')})\n"
        
        readme = README_TEMPLATE.format(
            name=self.skill['name'],
            tagline=readme_config.get('tagline', self.skill['description']),
            description=self.skill['description'],
            features=features_md,
            use_cases=use_cases_md,
            examples=examples_md,
            dependencies=deps_md,
            license=self.skill.get('license', 'Apache-2.0'),
            compiler_version=VERSION
        )
        
        (self.output_dir / 'README.md').write_text(readme)
        print(f"  ‚úì README.md")


def main():
    parser = argparse.ArgumentParser(
        description='wxo-skill-compiler: Convert declarative SKILL.yaml ‚Üí watsonx MCP server',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  wxo compile vault-auditor.skill.yaml
  wxo compile my-skill.yaml --output-dir ./generated/my-skill
  
Documentation: https://github.com/YOUR-ORG/wxo-skill-compiler
        '''
    )
    
    parser.add_argument('skill_file', type=Path, help='Path to SKILL.yaml file')
    parser.add_argument('-o', '--output-dir', type=Path, help='Output directory (default: skill name)')
    parser.add_argument('-v', '--version', action='version', version=f'wxo-skill-compiler {VERSION}')
    
    args = parser.parse_args()
    
    if not args.skill_file.exists():
        print(f"‚ùå Error: Skill file not found: {args.skill_file}")
        sys.exit(1)
    
    try:
        compiler = SkillCompiler(args.skill_file, args.output_dir)
        compiler.compile()
    except Exception as e:
        print(f"‚ùå Compilation failed: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
